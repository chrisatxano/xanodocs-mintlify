---
title: "Unit Tests"
icon: vial
---

## Building a Unit Test

The fastest way to create a unit test is by using Run & Debug. Once you are achieving the desired result by running your function stack, you can click **Create Unit Test** under the result.

<Frame caption="">
  <img src="/images/f55250f4-image.jpeg" />
</Frame>

You can also create a test manually at any time from the API settings menu.

<Frame caption="">
  <img src="/images/4145e564-image.jpeg" />
</Frame>

Give your unit test a name, a description, and the data source that it should use to run the test if different from your live data source.

<Frame caption="">
  <img src="/images/8eef8083-image.jpeg" />
</Frame>

Unit tests are defined by your **input** and **expects**.

<Frame caption="">
  <img src="/images/86e21a5e-image.jpeg" />
</Frame>

In this example, we are providing an input of 2 and expect a response of 2.

* **Inputs** align with the inputs that your function stack expects. You can fill out any desired values here that you would like to use to run the test. If you used the **Create Unit Test** option in Run & Debug, this should already be populated for you.

* **Expects** are the statements that are used to validate your test. These could be anything from a simple equals statement, or use more complex operators based on your needs.

Your unit test can have multiple expect statements, which can be added by clicking the **+ Add an expect statement** option.

* Use the ✏️ button to delete expect statements.

* Use the ⏩ button to check all expect statements, or you can run them selectively with the ▶️ button.

**Unit Tests and Authentication**

When creating a unit test on a function stack that requires authentication, you can provide an auth token and extras just like you would during Run & Debug.

To avoid having to recycle the auth token upon expiration, we have added the ability to ignore auth token expiration when running your unit tests.

<Frame caption="">
  <img src="/images/f56a16b8-image.jpeg" />
</Frame>

#### Using the Testing Suite

Once you have your unit tests built, you can always run them individually from that API's testing panel. If you want to run all of your tests at once, you can use the testing suite.

<Frame caption="">
  <img src="/images/33d947ec-image.jpeg" />
</Frame>

In the left-hand navigation menu, find your Library and click Unit Tests.

<Frame caption="">
  <img src="/images/fe8ca60b-image.jpeg" />
</Frame>

Once inside the testing suite, you can perform the following actions:

* Review where your application has and is missing coverage.

* Run all tests at once.

For complex applications with a significant number of objects, you have the ability to dial down further into checking coverage and tests for functions, APIs, and middleware separately. You can also filter your tests by tested / untested only, or failed only, to quickly understand where your attention should be to ensure 100% coverage and success.

## Mocking Responses

For each of the functions in your function stack, you can add *mock responses* to assist in the consistency of your unit tests.

<Steps>
  <Step title="Right-click on a function and choose Mock Test Response">
    <Frame caption="">
      <img src="/images/e8265537-image.jpeg" />
    </Frame>
  </Step>
  <Step title="In the panel that opens on the right, you can add mock data for this function that will be used during your unit test.">
    You can specify different pieces of data for each individual unit test you've built for this function stack.

    <Frame caption="">
      <img src="/images/a4b0cee9-image.jpeg" />
    </Frame>
  </Step>
</Steps>